<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Writing Simple WebSocket Server in Python: PyWSocket | Superuser</title>
<meta name="keywords" content="python, websocket">
<meta name="description" content="Echo websocket server implemented by hand on raw TCP Sockets.
Journey to websocket was pretty long. I started with an idea to make an app which can play music in sync across the devices during college period. No wonder I couldn&rsquo;t get through it. Later this year I stumbled upon this new thing called WebSockets and they were intriguing. I thought I could finish that app with websockets (and I did, with partial success).">
<meta name="author" content="Sanket">
<link rel="canonical" href="http://localhost:1313/posts/websocket-server-python/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/websocket-server-python/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Superuser (Alt + H)">Superuser</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Writing Simple WebSocket Server in Python: PyWSocket
    </h1>
    <div class="post-meta"><span title='2017-08-26 14:40:53 +0000 +0000'>August 26, 2017</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Sanket

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="http://localhost:1313/wp-content/uploads/2017/08/pywsocket-825x463.jpg" alt="">
        
</figure>
  <div class="post-content"><p>Echo websocket server implemented by hand on raw TCP Sockets.</p>
<p>Journey to websocket was pretty long. I started with an idea to make an app which can play music in sync across the devices during college period. No wonder I couldn&rsquo;t get through it. Later this year I stumbled upon this new thing called WebSockets and they were intriguing. I thought I could finish that app with websockets (and I did, with partial success). Spinned of another app out of it. And websockets were on a roll. It was time I digged further in and ended up writing a websocket server. (GitHub link at the bottom)</p>
<blockquote>
<p><strong>Update:</strong> Links to production grade websocket implementations at bottom.</p>
</blockquote>
<h3 id="so-what-is-a-websocket-server">So what is a websocket server?<a hidden class="anchor" aria-hidden="true" href="#so-what-is-a-websocket-server">#</a></h3>
<blockquote>
<p>A WebSocket server is a TCP application listening on any port of a server that follows a specific protocol, simple as that.</p>
</blockquote>
<p>How does it work? : It uses HTTP protocol for handshake and after handshake is complete, it works over TCP protocol and exchanges data in its agreed-upon format called frames. Connections are bi-directional and any party can send message anytime. Unlike HTTP where new TCP connection is made every time you want to communicate, WebSockets maintains a connection using which any side can send message anytime, reducing the message delivery time by using the existing connection.</p>
<p><img loading="lazy" src="https://www.fullstackpython.com/img/visuals/websockets-flow-with-client-push.png" alt="Websocket interaction"  />
</p>
<h2 id="the-websocket-server">The WebSocket Server:<a hidden class="anchor" aria-hidden="true" href="#the-websocket-server">#</a></h2>
<p>We will be writing our server in 4 parts:</p>
<ol>
<li>Writing a TCP/HTTP server to identify a websocket request.</li>
<li>Performing a handshake</li>
<li>Decoding/Receiving data/frames</li>
<li>Sending data/frames</li>
</ol>
<p>I will be discussing the protocol implementations as we go thru steps. You can also take a pause have a look at <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">this</a> awesome piece written by Mozilla on WebSocket Servers. It is a must read. Now or later.</p>
<h3 id="1-writing-a-tcphttp-server-to-identify-websocket-request">1. Writing a TCP/HTTP Server to Identify WebSocket Request<a hidden class="anchor" aria-hidden="true" href="#1-writing-a-tcphttp-server-to-identify-websocket-request">#</a></h3>
<p>We will be using python’s SocketServer library which ptovides simple TCP server. The client will send an HTTP request which looks something like this:</p>
<pre tabindex="0"><code>GET /chat HTTP/1.1
Host: example.com:8000
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
</code></pre><p>So what we need to lookout for is that if the request is of type GET and it has these three headers namely `Upgrade: websocket` `Connection: Upgrade` and `Sec-WebSocket-key: <!-- raw HTML omitted -->`</p>
<p>If you find all this, we can proceed towards the next step which is completing the handshake. In our implementation we will check if all the three headers are present and we will proceed with the handshake. The request handler function will look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># self.request is the TCP socket connected to the client</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)<span style="color:#f92672">.</span>strip()
</span></span><span style="display:flex;"><span>        headers <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>data<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># is it a websocket request?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;Connection: Upgrade&#34;</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>data <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;Upgrade: websocket&#34;</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># getting the websocket key out</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> h <span style="color:#f92672">in</span> headers:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;Sec-WebSocket-Key&#34;</span> <span style="color:#f92672">in</span> h:
</span></span><span style="display:flex;"><span>                    key <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34; &#34;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># let&#39;s shake hands shall we?</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>shake_hand(key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>                payload <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>decode_frame(bytearray(self<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)<span style="color:#f92672">.</span>strip()))
</span></span><span style="display:flex;"><span>                decoded_payload <span style="color:#f92672">=</span> payload<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>send_frame(payload)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;bye&#34;</span> <span style="color:#f92672">==</span> decoded_payload<span style="color:#f92672">.</span>lower():
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Bidding goodbye to our client...&#34;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>sendall(<span style="color:#e6db74">&#34;HTTP/1.1 400 Bad Request</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                                 <span style="color:#e6db74">&#34;Content-Type: text/plain</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                                 <span style="color:#e6db74">&#34;Connection: close</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                                 <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                                 <span style="color:#e6db74">&#34;Incorrect request&#34;</span>)
</span></span></code></pre></div><p>This is the rough flow: If we find a valid websocket request, we proceed with handshake and then in while loop, we just do echo. ie sending back whatever we received. If it’s not a valid request we send HTTP 400 in response.</p>
<p>Pretty simple till now, innit?</p>
<h3 id="2-performing-a-handshake">2. Performing a Handshake<a hidden class="anchor" aria-hidden="true" href="#2-performing-a-handshake">#</a></h3>
<p>This is where the protocol details kicks in. You will need to send a specific HTTP response back to client in order to establish the bidirectional connection. The response will look something like this:</p>
<pre tabindex="0"><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</code></pre><p>You see there a new header called <code>Sec-WebSocket-Accept</code> with some random looking characters. Now there&rsquo;s a method to calculate this. As per protocol, you concatenate the key you received in request header (‘dGhlIHNhb…’) and the <!-- raw HTML omitted -->magic string<!-- raw HTML omitted --> (“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”) , calcualte SHA1 hash of them and send back the base64 encoding of the hash (which is ‘s3pPLMB…’) This is done so that client can also confirm that the server understands the protocol. So handshake is basically HTTP response with a header containg SHA1 of the key and magic-string and key client sent and those same two headers.</p>
<p>Here&rsquo;s how it&rsquo;s done in python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shake_hand</span>(self,key):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># calculating response as per protocol RFC</span>
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> key <span style="color:#f92672">+</span> WS_MAGIC_STRING
</span></span><span style="display:flex;"><span>        resp_key <span style="color:#f92672">=</span> base64<span style="color:#f92672">.</span>standard_b64encode(hashlib<span style="color:#f92672">.</span>sha1(key)<span style="color:#f92672">.</span>digest())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        resp<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HTTP/1.1 101 Switching Protocols</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;Upgrade: websocket</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;Connection: Upgrade</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;Sec-WebSocket-Accept: </span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\r\n\r\n</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">%</span>(resp_key)
</span></span></code></pre></div><p>Here we send the key we received in request header as an argument and we use <em>hashlib</em> to calculate SHA1 and <em>base64</em> to encode it.</p>
<h3 id="3-decoding-an-incoming-frame">3. Decoding an Incoming Frame<a hidden class="anchor" aria-hidden="true" href="#3-decoding-an-incoming-frame">#</a></h3>
<p>Now that the connection is established, client/the other side can send us data. Now the data won’t be in plain-text. It is using a special frame format defined in protocol. A frame looks something like this:</p>
<pre tabindex="0"><code>      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
</code></pre><p>I will discuss the fields which we will be using here. Please read that <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">Mozilla article</a> I mentioned before to get more idea around this.</p>
<p>The FIN bit suggests that this is the last frame.We will assume/set it to 1 as we will be sending small amount of data only. Next 3 bits are reserved. The opcode suggests what kind of operation is this. 0x0 for continuation, 0x1 for text, 0x2 for binary etc. We will be using 0x1. The MASK bit we will discuss shortly.</p>
<p>Payload length is somewhat tricky. I am quoting the Mozilla Article here:</p>
<h4 id="Decoding_Payload_Length">Decoding Payload Length<a hidden class="anchor" aria-hidden="true" href="#Decoding_Payload_Length">#</a></h4>
<p>To read the payload data, you must know when to stop reading. That&rsquo;s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</p>
<ol>
<li>Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it&rsquo;s 125 or less, then that&rsquo;s the length; you&rsquo;re <strong>done</strong>. If it&rsquo;s 126, go to step 2. If it&rsquo;s 127, go to step 3.</li>
<li>Read the next 16 bits and interpret those as an unsigned integer. You&rsquo;re <strong>done</strong>.</li>
<li>Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You&rsquo;re <strong>done</strong>.</li>
</ol>
<p>We are assuming it to be &lt;125. That will leave byte 2 to 6 as masking bytes. If you are using web browser console as a client (which we will) it will set the mask bit to 1. Hence the payload will be masked. You can use XOR operation with the mask to get the original data back. The code to help you understand it better:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decode_frame</span>(self,frame):
</span></span><span style="display:flex;"><span>        opcode_and_fin <span style="color:#f92672">=</span> frame[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># assuming it&#39;s masked, hence removing the mask bit(MSB) to get len. also assuming len is &lt;125</span>
</span></span><span style="display:flex;"><span>        payload_len <span style="color:#f92672">=</span> frame[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">128</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mask <span style="color:#f92672">=</span> frame [<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>        encrypted_payload <span style="color:#f92672">=</span> frame [<span style="color:#ae81ff">6</span>: <span style="color:#ae81ff">6</span><span style="color:#f92672">+</span>payload_len]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">=</span> bytearray([ encrypted_payload[i] <span style="color:#f92672">^</span> mask[i<span style="color:#f92672">%</span><span style="color:#ae81ff">4</span>] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(payload_len)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> payload
</span></span></code></pre></div><p>We sent frame as a bytearray as you noticed in the first function <code>handle</code>. The operations are quite self explanatory. To get the payload length, we are subtracting 128 (the mask bit) from byte 1. (look at the frame structure and you&rsquo;ll have a clear picture) Encrypted payload XORed with the mask will give us the decrypted payload.</p>
<h3 id="4-sending-frames">4. Sending Frames<a hidden class="anchor" aria-hidden="true" href="#4-sending-frames">#</a></h3>
<p>While sending frames, we will do nothing fancy. We will not set MASK bit and we will send data unmasked i.e. in plain text. So that will leave us with filling the FIN bit, the OPCODE, the LEN and finally the payload. Have a look:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send_frame</span>(self, payload):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># setting fin to 1 and opcpde to 0x1</span>
</span></span><span style="display:flex;"><span>        frame <span style="color:#f92672">=</span> [<span style="color:#ae81ff">129</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># adding len. no masking hence not doing +128</span>
</span></span><span style="display:flex;"><span>        frame <span style="color:#f92672">+=</span> [len(payload)]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># adding payload</span>
</span></span><span style="display:flex;"><span>        frame_to_send <span style="color:#f92672">=</span> bytearray(frame) <span style="color:#f92672">+</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>sendall(frame_to_send)
</span></span></code></pre></div><p>Yep, that easy. So that wraps up our server. Now let&rsquo;s have a look at how can we make it on roll. Fire up a web browser console and try these out:</p>
<p><img loading="lazy" src="/wp-content/uploads/2017/08/websocket_js.png" alt="websocket_js"  />
</p>
<p>We asked our browser side websocket to print whatever it receives in console. And our server is sending back whatever the client sends. So there you are. The mighty WebSockets with &lt;80 lines of python code 😀 Check it out on <a href="https://github.com/sanketplus/PyWSocket">GitHub</a>.</p>
<p>Some interesting links which helped me get here:</p>
<ol>
<li><a href="https://www.fullstackpython.com/websockets.html">https://www.fullstackpython.com/websockets.html</a></li>
<li><a href="https://blog.pusher.com/websockets-from-scratch/">https://blog.pusher.com/websockets-from-scratch</a></li>
</ol>
<p>If you want production grade websocket implementations:</p>
<ol>
<li><a href="https://github.com/crossbario/autobahn-python">Autobahn-Python</a></li>
<li><a href="https://aiohttp.readthedocs.io/en/stable/">aiohttp</a> (I have used this personally)</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/python/">Python</a></li>
      <li><a href="http://localhost:1313/tags/websocket/">Websocket</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Superuser</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
