<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8080&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Golang Http Client and Compression | Superuser</title>
<meta name="keywords" content="">
<meta name="description" content="I had a very (seemingly) simple task. Verify my golang http client, talking with an ElasticSearch cluster, is compressing data on wire. Because in trials, there was around 8x data compression and 100ms latency improvement. Sounds simple? Apparently not!
ElasticSearch Side of Things Http compression is enabled by default and it&rsquo;s an easy configuration. Despite it being enabled by default, still added following in config
http.compression: true And verified it works by">
<meta name="author" content="sanket">
<link rel="canonical" href="http://localhost:8080/posts/2020-03-31-golang-http-gzip-compression/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:8080/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:8080/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:8080/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:8080/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:8080/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:8080/posts/2020-03-31-golang-http-gzip-compression/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:8080/" accesskey="h" title="Superuser (Alt + H)">Superuser</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:8080/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:8080/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Golang Http Client and Compression
    </h1>
    <div class="post-meta"><span title='2020-03-31 00:00:00 +0000 UTC'>March 31, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;sanket

</div>
  </header> 
  <div class="post-content"><p>I had a very (seemingly) simple task. Verify my golang http client, talking with an ElasticSearch cluster, is compressing data on wire. Because in trials, there was around 8x data compression and 100ms latency improvement. Sounds simple? Apparently not!</p>
<h1 id="elasticsearch-side-of-things">ElasticSearch Side of Things<a hidden class="anchor" aria-hidden="true" href="#elasticsearch-side-of-things">#</a></h1>
<p>Http compression is enabled by default and it&rsquo;s an easy configuration. Despite it being enabled by default, still added following in config</p>
<pre tabindex="0"><code>http.compression: true
</code></pre><p>And verified it works by</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>~ $&gt; curl -v http://localhost:9200/_cat/health -H <span style="color:#e6db74">&#34;Accept-Encoding: gzip&#34;</span>
</span></span><span style="display:flex;"><span>&gt; GET /_cat/health HTTP/1.1
</span></span><span style="display:flex;"><span>&gt; User-Agent: curl/7.29.0
</span></span><span style="display:flex;"><span>&gt; Host: localhost:9200
</span></span><span style="display:flex;"><span>&gt; Accept: */*
</span></span><span style="display:flex;"><span>&gt; Accept-Encoding: gzip
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>&lt; HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>&lt; content-type: text/plain; charset<span style="color:#f92672">=</span>UTF-8
</span></span><span style="display:flex;"><span>&lt; content-encoding: gzip
</span></span><span style="display:flex;"><span>&lt; content-length: <span style="color:#ae81ff">84</span>
</span></span><span style="display:flex;"><span>&lt;
</span></span></code></pre></div><h1 id="client-side-of-things">Client Side of Things<a hidden class="anchor" aria-hidden="true" href="#client-side-of-things">#</a></h1>
<p>We are using <a href="https://github.com/olivere/elastic">olivere/elastic</a> client to talk with ElasticSearch. This client takes a config parameter which is documented as following</p>
<pre tabindex="0"><code> SetGzip(bool) enables or disables compression on the request side. It is disabled by default.
</code></pre><p>Now this setting is <strong><em>supposed to</em></strong> enable compression. It does not. We will come to it. [Point 1]</p>
<p>Above ElasticSearch client also accepts an http client. And an HTTP client&rsquo;s transport as well has a compression flag. Here&rsquo;s how an HTTP client looks like, with compression enabled, which is what we had.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#a6e22e">tr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">MaxIdleConns</span>:       <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">IdleConnTimeout</span>:    <span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">DisableCompression</span>: <span style="color:#66d9ef">false</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">tr</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resp</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;https://example.com&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Documentation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// DisableCompression, if true, prevents the Transport from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// requesting compression with an &#34;Accept-Encoding: gzip&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// request header when the Request contains no existing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Accept-Encoding value. If the Transport requests gzip on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// its own and gets a gzipped response, it&#39;s transparently
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// decoded in the Response.Body. However, if the user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// explicitly requested gzip it is not automatically
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// uncompressed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">DisableCompression</span> <span style="color:#66d9ef">bool</span>
</span></span></code></pre></div><p>But how do I verify that the communication indeed was compressing data on the wire?</p>
<h2 id="inspect-requestresponse-headers-from-elasticsearch-client">Inspect Request/Response Headers From ElasticSearch Client<a hidden class="anchor" aria-hidden="true" href="#inspect-requestresponse-headers-from-elasticsearch-client">#</a></h2>
<p>I tried printing request response headers right at the place where the ES client performs the request. Pardon the formatting but they looked like following. You can see the request data is zipped but <code>Accept-Encoding</code> is missing. This is one problem that I mentioned. (Perhaps the <code>Vary</code> header is somehow able to achieve that but could not find anything promising). So the library&rsquo;s documentation is bit unclear to me.</p>
<pre tabindex="0"><code>map[User-Agent:[elastic/5.0.64 (linux-amd64)] Accept:[application/json] Content-Type:[application/json] Content-Encoding:[gzip] Vary:[Accept-Encoding]]
</code></pre><h2 id="inspect-headers-at-httptransport">Inspect Headers at http.transport<a hidden class="anchor" aria-hidden="true" href="#inspect-headers-at-httptransport">#</a></h2>
<p>Since we enabled compression at transport layer, it is supposed to send relevant headers and compress the payload. Diving into source code of transport, I saw a <a href="https://golang.org/src/net/http/transport.go#L2454">line setting <code>Accept-Encoding</code> header</a>. <code>req.extraHeaders().Set(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</code> But printing header did not show that encoding header. Apparently is was set in another variable of struct <code>transportRequest</code> called <code>extra</code></p>
<pre tabindex="0"><code>req header at transport:  
map[Vary:[Accept-Encoding] User-Agent:[elastic/5.0.64 (linux-amd64)] Accept:[application/json] Content-Type:[application/json] Content-Encoding:[gzip]]

extra:
map[Accept-Encoding:[gzip]]
</code></pre><h3 id="inspecting-response">Inspecting Response<a hidden class="anchor" aria-hidden="true" href="#inspecting-response">#</a></h3>
<p>The same function, which set the above header, receives the response. Printing response&rsquo;s header did not have content encoding.</p>
<pre tabindex="0"><code>// Src code:
    case re := &lt;-resc:
      if (re.res == nil) == (re.err == nil) {
        panic(fmt.Sprintf(&#34;internal error: exactly one of res or err should be set; nil=%v&#34;, re.res == nil))
      }
      if debugRoundTrip {
        req.logf(&#34;resc recv: %p, %T/%#v&#34;, re.res, re.err, re.err)
      }
      if re.err != nil {
        return nil, pc.mapRoundTripError(req, startBytesWritten, re.err)
      }
      fmt.Println(&#34;TRANSPORT RESS-=========-&#34;)
      fmt.Println(re.res.Header)
      fmt.Println(&#34;-=========-&#34;)

// Outout:
map[Content-Type:[application/json; charset=UTF-8]]
</code></pre><p><strong>This is where things get confusing. In the initial curl request, when we set the <code>Accept-Encoding</code> header, the ES server returned gzip response. But when go client set the same header, it did not return gzipped response.</strong></p>
<h3 id="going-further-deep">Going Further Deep<a hidden class="anchor" aria-hidden="true" href="#going-further-deep">#</a></h3>
<p>Something seemed wrong, so I went even deeper, to whatever function above transport&rsquo;s <code>roundTrip</code> function was calling. Control seemed to be going to <a href="https://golang.org/src/net/http/transport.go#L1943">function called <code>readLoop()</code></a> where we can find following lines scrolling down a bit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>    <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Body</span> = <span style="color:#a6e22e">body</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rc</span>.<span style="color:#a6e22e">addedGzip</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">EqualFold</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Header</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;Content-Encoding&#34;</span>), <span style="color:#e6db74">&#34;gzip&#34;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;TRANSPORT RESPPPPPP -=========-&#34;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Header</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Body</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gzipReader</span>{<span style="color:#a6e22e">body</span>: <span style="color:#a6e22e">body</span>}
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Header</span>.<span style="color:#a6e22e">Del</span>(<span style="color:#e6db74">&#34;Content-Encoding&#34;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Header</span>.<span style="color:#a6e22e">Del</span>(<span style="color:#e6db74">&#34;Content-Length&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">TRANSPORT</span> <span style="color:#a6e22e">RESPPPPPP</span> <span style="color:#f92672">-=========-</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Content</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Type</span>:[<span style="color:#a6e22e">application</span><span style="color:#f92672">/</span><span style="color:#a6e22e">json</span>; <span style="color:#a6e22e">charset</span>=<span style="color:#a6e22e">UTF</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>] <span style="color:#a6e22e">Content</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Encoding</span>:[<span style="color:#a6e22e">gzip</span>] <span style="color:#a6e22e">Content</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Length</span>:[<span style="color:#ae81ff">128</span>]]
</span></span></code></pre></div><p>HELL YEAH! There they are! The response was decompressed and headers were removed. That is why, at layers above this, we were not seeing the header set.</p>
<h1 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h1>
<ol>
<li>
<p>We set DisableCompression as false in http client&rsquo;s transport</p>
</li>
<li>
<p>Transport, for each request, if not already set, will set <code>Accept-Encoding</code>. (In a variable called extra)</p>
</li>
<li>
<p>When the response arrives, it&rsquo;ll check if transport added gzip</p>
<p>3.1 If it did, unzip data<!-- raw HTML omitted -->
3.2 Remove headers which indicates the zipped response from server.</p>
</li>
</ol>
<p>So it works good as a transparent system.</p>
<h1 id="the-twist">The Twist<a hidden class="anchor" aria-hidden="true" href="#the-twist">#</a></h1>
<p>Apparently http.Response struct had a field called <code>Uncompressed</code> which states exactly what I investigated. <strong>RTFM!</strong></p>
<pre tabindex="0"><code>    // Uncompressed reports whether the response was sent compressed but
    // was decompressed by the http package. When true, reading from
    // Body yields the uncompressed content instead of the compressed
    // content actually set from the server, ContentLength is set to -1,
    // and the &#34;Content-Length&#34; and &#34;Content-Encoding&#34; fields are deleted
    // from the responseHeader. To get the original response from
    // the server, set Transport.DisableCompression to true.
    Uncompressed bool // Go 1.7s
</code></pre><h3 id="fin">Fin<a hidden class="anchor" aria-hidden="true" href="#fin">#</a></h3>
<p>When I read <a href="https://fasterthanli.me/blog/2020/i-want-off-mr-golangs-wild-ride/">I want off Mr. Golang&rsquo;s Wild Ride</a>, the author&rsquo;s criticism felt valid to me. Later I realized even http timeouts are not as simple as they sound, <a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/">this piece on cloudflare blog</a> explains that. And now this abstraction for gzip! <strong>I feel the convenience that the language gives is good, until it&rsquo;s not!</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:8080/">Superuser</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
