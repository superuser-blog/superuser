<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Debugging a Running Python Process | Superuser</title>
<meta name="keywords" content="">
<meta name="description" content="Only if it were as easy as installing debug symbols, attach the process with gdb and py-bt! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on debugging a stuck process, but this was the opposite.">
<meta name="author" content="sanket">
<link rel="canonical" href="https://example.org/posts/2019-12-18-gdb-python/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css" integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Debugging a Running Python Process" />
<meta property="og:description" content="Only if it were as easy as installing debug symbols, attach the process with gdb and py-bt! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on debugging a stuck process, but this was the opposite." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/2019-12-18-gdb-python/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-12-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Debugging a Running Python Process"/>
<meta name="twitter:description" content="Only if it were as easy as installing debug symbols, attach the process with gdb and py-bt! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on debugging a stuck process, but this was the opposite."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Debugging a Running Python Process",
      "item": "https://example.org/posts/2019-12-18-gdb-python/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Debugging a Running Python Process",
  "name": "Debugging a Running Python Process",
  "description": "Only if it were as easy as installing debug symbols, attach the process with gdb and py-bt! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on debugging a stuck process, but this was the opposite.",
  "keywords": [
    
  ],
  "articleBody": "Only if it were as easy as installing debug symbols, attach the process with gdb and py-bt! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on debugging a stuck process, but this was the opposite. Time to dive deep.\nFirst Obvious Step: strace ... open(\"/\", O_RDONLY|O_CLOEXEC) = 4 fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0 close(4) = 0 open(\"/\", O_RDONLY|O_CLOEXEC) = 4 fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0 close(4) = 0 open(\"/\", O_RDONLY|O_CLOEXEC) = 4 fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0 close(4) = 0 ... So for some reason, the process is constantly opening root dir and calling fstat on it. Why? I don’t know!\npdb? Cannot work, because\nI have not worked with it before (I really should) Problem is not reproducible, the 100% CPU usage appeared on random hosts so stopping a process is not an option. Attach gdb to the process? Sure! I have heard it works with python too with extensions. There is this official DebuggingWithGdb guide which suggests vanilla steps of installing debug symbols with yum or apt-get. If life were that simple. The thing is we do not run on system python, the one that you find under /usr/bin/python. There is a separately compiled and packaged python installed on hosts at a non-standard location, so grabbing random debug symbols from the internet would not work.\nSearched on slack chat history (poor man’s stackoverflow!) if someone has tried this adventure earlier, and some people sure had. Got a link to debug symbol RPM from chat history and installed that\n$ sudo yum install python37-debuginfo.x86_64 And to get where exactly did that RPM install the debug binary (remember custom in-house built python? It does not install files at any standard location)\n$ sudo rpm -ql python37-debuginfo | less Search for a bin/python3.debug or something similar in that. Once you get the path to debug binary, it would be as simple as this, right?\n$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug Wrong! Turns out, when we attach gdb using that debug binary, it cannot load most symbols and errors out like\n$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug ... ... Reading symbols from /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug...done. Attaching to program: /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug, process 3536 Reading symbols from /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0...(no debugging symbols found)...done. Loaded symbols for /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0 Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done. [Thread debugging using libthread_db enabled] Loaded symbols for /lib64/libpthread.so.0 Reading symbols from /lib64/libdl.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/libdl.so.2 Reading symbols from /lib64/libutil.so.1...(no debugging symbols found)...done. Loaded symbols for /lib64/libutil.so.1 Reading symbols from /lib64/librt.so.1...(no debugging symbols found)...done. Loaded symbols for /lib64/librt.so.1 Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done. Loaded symbols for /lib64/libm.so.6 Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done. Missing separate debuginfos, use: debuginfo-install python37_3_7_0-0.0.9-3.7.0.el6.x86_64 Despite given the debug binary, gdb somehow is not able to load symbols. Meaning python binary that is run as a process and the debug binary that we provided do not correspond to the same version or build of python. The command on the last line did not work either saying package not found. Let’s first confirm the running python binary\n$ ps auxww | grep root 81.1 0.0 227152 40560 ? R 07:50 158:57 /foo/bar/python/3.7/bin/python3.7 /abc/def/python-app.pex $ sudo yum whatprovides /foo/bar/python/3.7/bin/python3.7 python37_3_7_0-0.0.9-3.7.0.el6.x86_64 : Python 3.7.0 from straightforward source build [On a side note, the running pex file is a PythonEXecutable, something like zipped virtualenv]\nApparently, the binary that runs python is 3.7.0 and build version 0.0.9 (not sure what exactly does that mean) and that version did not match with original debug binary I installed earlier. To find corresponding debug binary, which would not be available on the internet, I searched on local artifact store (remember debuginfo-install was not able to find it) where there was a promising-looking python37-debuginfo_linux_rhel6_x86_64-0.0.9-3.7.0.el6.x86_64.rpm which exactly corresponds to the binary version that process is running. Okay, now using same rpm -ql command we find the debug binary and run\n$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug ... Reading symbols from /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug...done. Attaching to program: /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug, process 3536 Reading symbols from /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0...Reading symbols from /usr/lib/debug/foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0.debug...done. done. Loaded symbols for /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0 So that symbols are getting loaded. Now just run py-bt and get backtrace, right? Wrong!\n(gdb) py-bt Undefined command: \"py-bt\". Try \"help\". Okay, gdb. That was supposed to work! Why did it not? Turns out, all these python related macros does not come built-in but they are kind of added at runtime. CPython interpreter ships with a script that gdb loads and these python magic macros work. That script in an ideal world, loads automatically and you don’t need to do anything. But remember where we live :) The script is called python37-gdb.py but it was for some strange reason not shipped with the debug binary installed. Again, in an ideal world, the script is supposed to come with the package and should be autoloaded. This is where you can get it from python source code Tools/gdb/libpython.py It is named a bit differently. During build time it gets renamed I guess. Anyway, here’s how you load the file and then the macros would work! Yeeeey!!!\n(gdb) source /path/to/libpython.py Now process was getting paused at some memcpy function. From original strace output it seemed to be getting stuck in an infinite open calls. So that’s our pointer. We set a breakpoint at open call and then take a backtrace. And we get to know who’s doing it!\n(gdb) break open Breakpoint 1 at 0x3a60a0ef70 (gdb) c Continuing. Breakpoint 1, 0x0000003a60a0ef70 in open64 () from /lib64/libpthread.so.0 (gdb) py-bt Traceback (most recent call first): File \"/foo/bar/python/3.7/lib/python3.7/zipfile.py\", line 180, in is_zipfile with open(filename, \"rb\") as fp: File \".bootstrap/pex/third_party/__init__.py\", line 104, in containing File \".bootstrap/pex/third_party/__init__.py\", line 156, in _iter_importables (frame information optimized out) (frame information optimized out) (frame information optimized out) (frame information optimized out) Cool stuff! We know form pex’s third party module we’re making those calls. Let’s go frame by frame\n(gdb) py-up #12 Frame 0x7fd73546c230, for file /foo/bar/python/3.7/lib/python3.7/zipfile.py, line 180, in is_zipfile (filename='/', result=False) with open(filename, \"rb\") as fp: (gdb) py-up #15 Frame 0x7fd737c02d30, for file .bootstrap/pex/third_party/__init__.py, line 104, in containing (cls=, root='/abc/def/python-app.pex/.bootstrap', prefix='//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////...(truncated) The second frame looks suspicious. The function containing has an argument prefix ‘/////////….’ and we also saw in our initial strace output the program opening ‘/’ repeatedly. So the dots connect. Next? Go to pex’s github repo and search for reported issues and there indeed was PR#638 Here’s the code snippet from the earlier version\nclass _ZipIterator(namedtuple('_ZipIterator', ['zipfile_path', 'prefix'])): @classmethod def containing(cls, root): prefix = '' path = root while path: if zipfile.is_zipfile(path): return cls(zipfile_path=path, prefix=prefix + os.sep if prefix else '') prefix = os.path.join(prefix, os.path.basename(path)) path = os.path.dirname(path) raise ValueError('Could not find the zip file housing {}'.format(root)) So this method is passed a zip argument (the pex python file) and zipfile.is_zipfile will return true and program proceeds happily. But when does it not, it modifies path as a parent dir using os.path.dirname(...) and while loop continues. The parent dir is not zip either, so it goes to its parent dir. And so it goes on till path is /. Now parent of / is / itself so while loop continues infinitely and we see 100% CPU usage and process doing nothing else. The issue is explained here by author who raised a fix.\nThe Root Cause So ideally the zip (.pex) file is supposed to exist. This particular scenario happened while we were moving away from pex. We install a newer packaged file and restart the process. But for some reason (which we will not discuss here) the process was not getting killed and it continued running with a pex file which did not exist anymore (hence is_zipfile fails) because of the upgrade to new packaging.\n",
  "wordCount" : "1327",
  "inLanguage": "en",
  "datePublished": "2019-12-18T00:00:00Z",
  "dateModified": "2019-12-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "sanket"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/2019-12-18-gdb-python/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Superuser",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="Superuser (Alt + H)">Superuser</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://example.org/">Home</a>&nbsp;»&nbsp;<a href="https://example.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Debugging a Running Python Process
    </h1>
    <div class="post-meta"><span title='2019-12-18 00:00:00 +0000 UTC'>December 18, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;sanket

</div>
  </header> 
  <div class="post-content"><p>Only if it were as easy as installing debug symbols, attach the process with gdb and <code>py-bt</code>! So we have a python agent, which distributes files, running across the fleet. And on some random hosts, it went haywire! On those set of hosts, the process was using 100% of CPU and not doing anything meaningful work. Restarting the process fixes the problem. I had worked on <a href="/debugging-stuck-process-linux/">debugging a stuck process</a>, but this was the opposite. Time to dive deep.</p>
<h1 id="first-obvious-step-strace">First Obvious Step: <code>strace</code><a hidden class="anchor" aria-hidden="true" href="#first-obvious-step-strace">#</a></h1>
<pre tabindex="0"><code>...
open(&#34;/&#34;, O_RDONLY|O_CLOEXEC)           = 4
fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0
close(4)                                = 0
open(&#34;/&#34;, O_RDONLY|O_CLOEXEC)           = 4
fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0
close(4)                                = 0
open(&#34;/&#34;, O_RDONLY|O_CLOEXEC)           = 4
fstat(4, {st_mode=S_IFDIR|0555, st_size=4096, ...}) = 0
close(4)                                = 0
...
</code></pre><p>So for <em>some</em> reason, the process is constantly opening root dir and calling fstat on it. Why? I don&rsquo;t know!</p>
<h1 id="pdb"><code>pdb</code>?<a hidden class="anchor" aria-hidden="true" href="#pdb">#</a></h1>
<p>Cannot work, because</p>
<ol>
<li>I have not worked with it before (I really should)</li>
<li>Problem is not reproducible, the 100% CPU usage appeared on random hosts so stopping a process is not an option.</li>
</ol>
<h1 id="attach-gdb-to-the-process">Attach <code>gdb</code> to the process?<a hidden class="anchor" aria-hidden="true" href="#attach-gdb-to-the-process">#</a></h1>
<p>Sure! I have heard it works with python too with extensions. There is this <a href="https://wiki.python.org/moin/DebuggingWithGdb">official DebuggingWithGdb guide</a> which suggests vanilla steps of installing debug symbols with <code>yum</code> or <code>apt-get</code>. If life were that simple. The thing is we do not run on system python, the one that you find under /usr/bin/python. There is a separately compiled and packaged python installed on hosts at a non-standard location, so grabbing random debug symbols from the internet would not work.</p>
<p>Searched on slack chat history (poor man&rsquo;s stackoverflow!) if someone has tried this adventure earlier, and some people sure had. Got a link to debug symbol RPM from chat history and installed that</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo yum install python37-debuginfo.x86_64
</span></span></code></pre></div><p>And to get where exactly did that RPM install the debug binary (remember custom in-house built python? It does not install files at any standard location)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo rpm -ql python37-debuginfo | less
</span></span></code></pre></div><p>Search for a <code>bin/python3.debug</code> or something similar in that. Once you get the path to debug binary, it would be as simple as this, right?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug &lt;PID&gt;
</span></span></code></pre></div><p>Wrong! Turns out, when we attach gdb using that debug binary, it cannot load most symbols and errors out like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug &lt;PID&gt;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span></span><span style="display:flex;"><span>Reading symbols from /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug...done.
</span></span><span style="display:flex;"><span>Attaching to program: /usr/lib/debug/foo/bar/python/3.7.1/bin/python3.7.debug, process <span style="color:#ae81ff">3536</span>
</span></span><span style="display:flex;"><span>Reading symbols from /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/libpthread.so.0...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Thread debugging using libthread_db enabled<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /lib64/libpthread.so.0
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/libdl.so.2...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /lib64/libdl.so.2
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/libutil.so.1...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /lib64/libutil.so.1
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/librt.so.1...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /lib64/librt.so.1
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/libm.so.6...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /lib64/libm.so.6
</span></span><span style="display:flex;"><span>Reading symbols from /lib64/libc.so.6...<span style="color:#f92672">(</span>no debugging symbols found<span style="color:#f92672">)</span>...done.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Missing separate debuginfos, use: debuginfo-install python37_3_7_0-0.0.9-3.7.0.el6.x86_64
</span></span></code></pre></div><p>Despite given the debug binary, gdb somehow is not able to load symbols. Meaning python binary that is run as a process and the debug binary that we provided do not correspond to the same version or build of python. The command on the last line did not work either saying package not found. Let&rsquo;s first confirm the running python binary</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ ps auxww | grep &lt;PID&gt;
</span></span><span style="display:flex;"><span>root      &lt;PID&gt; 81.1  0.0 <span style="color:#ae81ff">227152</span> <span style="color:#ae81ff">40560</span> ?        R    07:50 158:57 /foo/bar/python/3.7/bin/python3.7 /abc/def/python-app.pex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sudo yum whatprovides /foo/bar/python/3.7/bin/python3.7
</span></span><span style="display:flex;"><span>python37_3_7_0-0.0.9-3.7.0.el6.x86_64 : Python 3.7.0 from straightforward source build
</span></span></code></pre></div><p>[On a side note, the running pex file is a PythonEXecutable, something like zipped virtualenv]</p>
<p>Apparently, the binary that runs python is 3.7.0 and build version 0.0.9 (not sure what exactly does that mean) and that version did not match with original debug binary I installed earlier. To find corresponding debug binary, which would not be available on the internet, I searched on local artifact store (remember <code>debuginfo-install</code> was not able to find it) where there was a promising-looking <code>python37-debuginfo_linux_rhel6_x86_64-0.0.9-3.7.0.el6.x86_64.rpm</code> which exactly corresponds to the binary version that process is running. Okay, now using same <code>rpm -ql</code> command we find the debug binary and run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo gdb /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug &lt;PID&gt;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Reading symbols from /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug...done.
</span></span><span style="display:flex;"><span>Attaching to program: /usr/lib/debug/foo/bar/python/3.7.0/bin/python3.debug, process <span style="color:#ae81ff">3536</span>
</span></span><span style="display:flex;"><span>Reading symbols from /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0...Reading symbols from /usr/lib/debug/foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0.debug...done.
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>Loaded symbols <span style="color:#66d9ef">for</span> /foo/bar/python/3.7.0/lib/libpython3.7m.so.1.0
</span></span></code></pre></div><p>So that symbols are getting loaded. Now just run <code>py-bt</code> and get backtrace, right? Wrong!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> py-bt
</span></span><span style="display:flex;"><span>Undefined command: <span style="color:#e6db74">&#34;py-bt&#34;</span>.  Try <span style="color:#e6db74">&#34;help&#34;</span>.
</span></span></code></pre></div><p>Okay, gdb. That was supposed to work! Why did it not? Turns out, all these <a href="https://fedoraproject.org/wiki/Features/EasierPythonDebugging#New_gdb_commands">python related macros</a> does not come built-in but they are kind of added at runtime. CPython interpreter ships with a script that gdb loads and these python magic macros work. That script in an ideal world, loads automatically and you don&rsquo;t need to do anything. But remember where we live :) The script is called <code>python37-gdb.py</code> but it was for some strange reason not shipped with the debug binary installed. Again, in an ideal world, the script is supposed to come with the package and should be autoloaded. This is where you can get it from python source code <a href="https://github.com/python/cpython/blob/v3.7.0/Tools/gdb/libpython.py">Tools/gdb/libpython.py</a> It is named a bit differently. During build time it gets renamed I guess. Anyway, here&rsquo;s how you load the file and then the macros would work! Yeeeey!!!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> source /path/to/libpython.py
</span></span></code></pre></div><p>Now process was getting paused at some memcpy function. <strong>From original strace output it seemed to be getting stuck in an infinite open calls. So that&rsquo;s our pointer. We set a breakpoint at open call and then take a backtrace. And we get to know who&rsquo;s doing it!</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> break open
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#ae81ff">1</span> at 0x3a60a0ef70
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 1, 0x0000003a60a0ef70 in open64 <span style="color:#f92672">()</span> from /lib64/libpthread.so.0
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> py-bt
</span></span><span style="display:flex;"><span>Traceback <span style="color:#f92672">(</span>most recent call first<span style="color:#f92672">)</span>:
</span></span><span style="display:flex;"><span>  &lt;built-in method open of module object at remote 0x7fd738659db8&gt;
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;/foo/bar/python/3.7/lib/python3.7/zipfile.py&#34;</span>, line 180, in is_zipfile
</span></span><span style="display:flex;"><span>    with open<span style="color:#f92672">(</span>filename, <span style="color:#e6db74">&#34;rb&#34;</span><span style="color:#f92672">)</span> as fp:
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;.bootstrap/pex/third_party/__init__.py&#34;</span>, line 104, in containing
</span></span><span style="display:flex;"><span>  File <span style="color:#e6db74">&#34;.bootstrap/pex/third_party/__init__.py&#34;</span>, line 156, in _iter_importables
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>frame information optimized out<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>frame information optimized out<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  &lt;built-in method exec of module object at remote 0x7fd738709c28&gt;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>frame information optimized out<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">(</span>frame information optimized out<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Cool stuff! We know form pex&rsquo;s third party module we&rsquo;re making those calls. Let&rsquo;s go frame by frame</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> py-up
</span></span><span style="display:flex;"><span><span style="color:#75715e">#12 Frame 0x7fd73546c230, for file /foo/bar/python/3.7/lib/python3.7/zipfile.py, line 180, in is_zipfile (filename=&#39;/&#39;, result=False)</span>
</span></span><span style="display:flex;"><span>    with open<span style="color:#f92672">(</span>filename, <span style="color:#e6db74">&#34;rb&#34;</span><span style="color:#f92672">)</span> as fp:
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> py-up
</span></span><span style="display:flex;"><span><span style="color:#75715e">#15 Frame 0x7fd737c02d30, for file .bootstrap/pex/third_party/__init__.py, line 104, in containing (cls=&lt;type at remote 0x26a2d48&gt;, root=&#39;/abc/def/python-app.pex/.bootstrap&#39;, prefix=&#39;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////...(truncated)</span>
</span></span></code></pre></div><p>The second frame looks suspicious. The function <code>containing</code> has an argument prefix &lsquo;/////////&hellip;.&rsquo; and we also saw in our initial strace output the program opening &lsquo;/&rsquo; repeatedly. So the dots connect. Next? Go to pex&rsquo;s github repo and search for reported issues and there indeed was <a href="https://github.com/pantsbuild/pex/pull/638">PR#638</a> Here&rsquo;s the code snippet from the earlier version</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_ZipIterator</span>(namedtuple(<span style="color:#e6db74">&#39;_ZipIterator&#39;</span>, [<span style="color:#e6db74">&#39;zipfile_path&#39;</span>, <span style="color:#e6db74">&#39;prefix&#39;</span>])):
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@classmethod</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">containing</span>(cls, root):
</span></span><span style="display:flex;"><span>    prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> path:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> zipfile<span style="color:#f92672">.</span>is_zipfile(path):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cls(zipfile_path<span style="color:#f92672">=</span>path, prefix<span style="color:#f92672">=</span>prefix <span style="color:#f92672">+</span> os<span style="color:#f92672">.</span>sep <span style="color:#66d9ef">if</span> prefix <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>      prefix <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(prefix, os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>basename(path))
</span></span><span style="display:flex;"><span>      path <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>dirname(path)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#39;Could not find the zip file housing </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(root))
</span></span></code></pre></div><p>So this method is passed a zip argument (the pex python file) and <code>zipfile.is_zipfile</code> will return true and program proceeds happily. But when does it not, it modifies path as a parent dir using <code>os.path.dirname(...)</code> and while loop continues. The parent dir is not zip either, so it goes to its parent dir. And so it goes on till path is <code>/</code>. Now parent of <code>/</code> is <code>/</code> itself so while loop continues infinitely and we see 100% CPU usage and process doing nothing else. The issue is <a href="https://github.com/pantsbuild/pex/pull/638/files#r273808423">explained here by author who raised a fix</a>.</p>
<h1 id="the-root-cause">The Root Cause<a hidden class="anchor" aria-hidden="true" href="#the-root-cause">#</a></h1>
<p>So ideally the zip (.pex) file is supposed to exist. This particular scenario happened while we were moving away from pex. We install a newer packaged file and restart the process. But for some reason (which we will not discuss here) the process was not getting killed and it continued running with a pex file which did not exist anymore (hence <code>is_zipfile</code> fails) because of the upgrade to new packaging.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://example.org/">Superuser</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
